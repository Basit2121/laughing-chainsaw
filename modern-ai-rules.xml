<?xml version="1.0" encoding="UTF-8"?>
<nextjs_fastapi_development_rules>
  
  <project_structure>
    <rule id="1">Separate frontend (Next.js) and backend (FastAPI) into distinct directories: /frontend and /backend</rule>
    <rule id="2">Use environment variables for configuration (e.g., API URLs, secrets) in both frontend (.env.local) and backend (.env)</rule>
    <rule id="3">Maintain clear separation of concerns between client-side and server-side code</rule>
    <rule id="4">Never commit sensitive config files to git; provide example files (e.g., .env.example) instead</rule>
  </project_structure>

  <frontend_nextjs_react>
    <rule id="5">Use functional components with React Hooks (useState, useEffect, useContext, etc.)</rule>
    <rule id="6">Implement proper error boundaries for graceful error handling</rule>
    <rule id="7">Use Next.js App Router (app directory) for modern routing patterns</rule>
    <rule id="8">Leverage server components by default, use 'use client' directive only when necessary</rule>
    <rule id="9">Implement proper loading states with loading.js and Suspense boundaries</rule>
    <rule id="10">Use Next.js Image component for optimized image loading</rule>
    <rule id="11">Implement proper SEO with metadata exports in each page</rule>
    <rule id="12">Use Tailwind CSS for styling with consistent utility classes throughout the application</rule>
    <rule id="13">Implement proper form validation on the client side</rule>
    <rule id="14">Use environment variables prefixed with NEXT_PUBLIC_ for client-side accessible variables</rule>
    <rule id="15">Write all frontend code in JavaScript, not TypeScript</rule>
    <rule id="16">Create reusable React components for common UI elements (navbar, sidebar, footer, buttons, modals)</rule>
    <rule id="17">Store reusable components in a dedicated /components directory with clear organization</rule>
    <rule id="18">DO NOT USE CLASS COMPONENTS - only use functional components with hooks</rule>
  </frontend_nextjs_react>

  <ui_ux_design>
    <rule id="19">Create modern, clean, and professional UI design using Tailwind CSS with clear visual hierarchy</rule>
    <rule id="20">Establish strong typography hierarchy using consistent heading levels (h1-h6) with appropriate font sizes, weights, and spacing</rule>
    <rule id="21">Maintain consistent spacing using Tailwind's spacing scale throughout all components and layouts</rule>
    <rule id="22">Ensure accessible color contrast ratios (WCAG AA compliant) for all text and interactive elements</rule>
    <rule id="23">Use semantic HTML5 elements to reinforce content structure and improve accessibility</rule>
    <rule id="24">Implement responsive design that works seamlessly across all device sizes (mobile, tablet, desktop)</rule>
    <rule id="25">Avoid using emojis in professional interface elements</rule>
    <rule id="26">Include high-quality, optimized images where applicable to enhance visual appeal without compromising performance</rule>
  </ui_ux_design>

  <backend_fastapi>
    <rule id="27">Use Pydantic models for request/response validation and serialization</rule>
    <rule id="28">Implement proper error handling with HTTPException and custom exception handlers</rule>
    <rule id="29">Use dependency injection for database connections, authentication, and shared logic</rule>
    <rule id="30">Organize routes using APIRouter for modular endpoint management</rule>
    <rule id="31">Structure backend with separate routers for each feature/domain (e.g., /routers/users.py, /routers/posts.py)</rule>
    <rule id="32">Implement proper CORS configuration to allow frontend origin</rule>
    <rule id="33">Use async/await patterns for I/O operations (database, external APIs)</rule>
    <rule id="34">Implement proper logging for debugging and monitoring</rule>
    <rule id="35">Use environment variables for sensitive configuration (database URLs, API keys)</rule>
    <rule id="36">Implement proper authentication and authorization (JWT, OAuth2, etc.)</rule>
    <rule id="37">Document API endpoints with OpenAPI/Swagger automatic documentation</rule>
    <rule id="38">Create a health check endpoint (e.g., /health or /api/health) that returns status and timestamp, and verifies database connectivity</rule>
    <rule id="39">DO NOT USE OOP - avoid creating classes for business logic; use pure functions and utility modules instead</rule>
    <rule id="40">Keep backend code simple and procedural - use functions that take inputs and return outputs</rule>
  </backend_fastapi>

  <api_communication>
    <rule id="41">Use RESTful API design principles with proper HTTP methods (GET, POST, PUT, DELETE)</rule>
    <rule id="42">Implement proper status codes (200, 201, 400, 401, 404, 500, etc.)</rule>
    <rule id="43">Use consistent JSON response format with proper error messages</rule>
    <rule id="44">Implement API versioning (e.g., /api/v1/) for backward compatibility</rule>
    <rule id="45">Use fetch or axios in frontend for API calls, wrap in try-catch blocks</rule>
    <rule id="46">Implement request/response interceptors for authentication tokens</rule>
    <rule id="47">Handle rate limiting and implement request throttling when necessary</rule>
  </api_communication>

  <security>
    <rule id="48">Never expose sensitive data or API keys in frontend code</rule>
    <rule id="49">Implement HTTPS in production environments</rule>
    <rule id="50">Sanitize user inputs on both frontend and backend</rule>
    <rule id="51">Use prepared statements or ORM to prevent SQL injection</rule>
    <rule id="52">Implement CSRF protection for state-changing operations</rule>
    <rule id="53">Set secure HTTP headers (Content-Security-Policy, X-Frame-Options, etc.)</rule>
    <rule id="54">Implement proper password hashing (bcrypt, argon2) for user credentials</rule>
    <rule id="55">Use secure session management and token expiration</rule>
  </security>

  <database>
    <rule id="56">Use an ORM like SQLAlchemy or Tortoise ORM for database operations</rule>
    <rule id="57">Implement database migrations for schema version control using Alembic or similar tools</rule>
    <rule id="58">Store database schema definitions separately and maintain migration history</rule>
    <rule id="59">Use connection pooling for efficient database connections</rule>
    <rule id="60">Implement proper indexing for optimized query performance</rule>
    <rule id="61">Never expose raw database errors to the client</rule>
    <rule id="62">Separate database logic from business logic and API route handlers</rule>
    <rule id="63">Write database utility functions instead of database classes - use simple functions for queries and updates</rule>
  </database>

  <performance>
    <rule id="64">Implement caching strategies (Redis, in-memory) for frequently accessed data</rule>
    <rule id="65">Use pagination for large data sets in API responses</rule>
    <rule id="66">Implement lazy loading for components and images in frontend</rule>
    <rule id="67">Optimize database queries to avoid N+1 problems</rule>
    <rule id="68">Use Next.js static generation where possible for better performance</rule>
    <rule id="69">Implement proper code splitting in frontend bundle</rule>
  </performance>

  <code_quality_and_simplicity>
    <rule id="70">CRITICAL: DO NOT USE OBJECT-ORIENTED PROGRAMMING (OOP) - avoid creating classes for business logic, services, or utilities</rule>
    <rule id="71">Write procedural, functional code that is simple and easy to understand</rule>
    <rule id="72">Use pure functions wherever possible - functions should have clear inputs and outputs without side effects</rule>
    <rule id="73">Keep functions small and focused on single responsibility (max 20-30 lines per function)</rule>
    <rule id="74">Use descriptive function names that clearly indicate their purpose (verb-noun format: get_user, create_post, validate_email)</rule>
    <rule id="75">Include docstrings/comments for all functions explaining purpose, parameters, return values, and any side effects</rule>
    <rule id="76">Avoid deep nesting - use early returns and guard clauses to flatten code structure (max 2-3 levels of indentation)</rule>
    <rule id="77">Use meaningful variable names that describe their purpose, avoiding single-letter names except for simple iterators</rule>
    <rule id="78">Follow consistent naming conventions (camelCase for JavaScript, snake_case for Python)</rule>
    <rule id="79">Use ESLint and Prettier for frontend code formatting</rule>
    <rule id="80">Use Black and isort for backend Python code formatting</rule>
    <rule id="81">Follow PEP 8 style guidelines for Python code</rule>
    <rule id="82">Add comments for complex logic, not obvious code</rule>
    <rule id="83">Keep dependencies up to date and audit for security vulnerabilities</rule>
    <rule id="84">Avoid global variables - use function parameters and return values to pass data between functions</rule>
    <rule id="85">Separate concerns clearly - database logic, business logic, and presentation logic should be in different modules/files</rule>
    <rule id="86">Organize code in simple utility modules with related functions grouped together (e.g., db_utils.py, auth_utils.py, validation_utils.py)</rule>
    <rule id="87">Keep code readable and maintainable - prioritize clarity over cleverness</rule>
    <rule id="88">Write self-documenting code where the logic is clear from variable and function names alone</rule>
  </code_quality_and_simplicity>

  <development_workflow>
    <rule id="89">Include a requirements.txt or pyproject.toml file for Python dependencies</rule>
    <rule id="90">Include a package.json file for JavaScript dependencies</rule>
    <rule id="91">Provide clear setup instructions in README.md for both frontend and backend</rule>
    <rule id="92">Include .gitignore files to exclude node_modules, venv, __pycache__, .env files, and build artifacts</rule>
    <rule id="93">Enable hot-reload for development: Next.js dev server auto-reloads on changes, use uvicorn --reload for FastAPI</rule>
  </development_workflow>

</nextjs_fastapi_development_rules>
